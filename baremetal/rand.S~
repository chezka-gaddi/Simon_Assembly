	.equ	GPLEV0,    0x0034

	.text

@@ makes a random number base on when the button is press.
@@ must press in first 4 seconds of program running!!!!
	.global rand
rand:
	stmfd	sp!, {r4,lr}
	mov	r4, #0

rand_loop:	
	add	r4, r4, #1
	bl	console 
	cmp	r0, #0
	
	beq	rand_loop
	mov	r0, r4
	ldmfd	sp!, {r4,pc}


@@ does calculations to get value to store in array
	.global int_rand
int_rand:
	stmfd	sp!, {r4,lr}
	//add	    r1, r1, #3	@ stop dividing by 0
	//bl	    udiv32		@ takes large random number divides by counter
	mov	    r1, #4		@ divides quotient by 4
	bl	    udiv32
	mov	    r4, r1		@ stores remainder into r4 number  
	add	    r4, r4, #1	@ gets number between 1-4
	mov	    r0, r4		@ moves r4 into r0 to return

	ldmfd	sp!,{r4,pc}

	
	@@@ ----------------------------------------------------------------
	@@@ divide.S
	@@@ Author: Larry Pyeatt
	@@@ Date: 10/16/2014
	@@@
	@@@ Division functions in ARM assembly language
	@@@ ----------------------------------------------------------------
	@@@ -----------------------------------------------------------------
	@@ udiv32 takes a 32-bit unsigned dividend in r0 and
	@@ divides it by a 32-bit unsigned divisor in r1.
	@@ Returns the quotient in r0 and remainder in r1
	@@ It calls no other functions and only
	@@ uses r0-r3. We don't need to use the stack
	.global	udiv32
udiv32:		
    cmp	    r1,#0		@ if divisor == zero
	beq	    quitudiv32	@   exit immediately
	mov     r2,r1           @ move divisor to r2
	mov     r1,r0           @ move dividend to r1
	mov     r0,#0           @ clear r0 to accumulate result
	mov     r3,#1           @ set "current" bit in r3
divstrt:	
    cmp	    r2,#0           @ WHILE ((msb of r2 != 1)
	blt	    divloop
	cmp     r2,r1		@ && (r2 < r1))
	lslls   r2,r2,#1        @  shift dividend left
	lslls   r3,r3,#1        @  shift "current" bit left
	bls     divstrt		@ end WHILE
divloop:	
    cmp     r1,r2           @ if dividend >= divisor
	subhs   r1,r1,r2        @   subtract divisor from dividend
	addhs   r0,r0,r3        @   set "current" bit in the result
	lsr	    r2,r2,#1	@ shift dividend right
	lsrs    r3,r3,#1	@ Shift current bit right into carry
	bcc     divloop         @ If carry not clear, R3 has shifted
	@ one bit past where it started, and we
	@ are done.
quitudiv32:
	mov     pc, lr



@@ waits for the user to press a button and returns the button that was pressed    
	.global console

/*console:
	stmfd	sp!,{r4-r7,lr}
	mov	r1, #0
	mov     r6, #0              @ r6: debounce counter
debounce:
	@@ Read the state of the buttons
	@@ Read GPIO Level Register 0 (GPLEV0)
	ldr         r0, [r4, #GPLEV0]

	tst     r0, #(1<<17)            @ check state of pin 22
	mov     r3, #1
	beq     compare

	tst     r0, #(1<<22)            @ check state of pin 23
	mov     r3, #2
	beq     compare

	tst     r0, #(1<<10)            @ check state of pin 24
	mov     r3, #3
	beq     compare

	tst     r0, #(1<<11)            @ check state of pin 24
	mov     r3, #4
	beq     compare

	add	r1, r1, #1

	mov     r6, #0
	b       debounce
compare:
	addeq   r6, r6, #1
	cmp     r6, #0x1FC000
	blt     debounce

	mov	r0, r3
	
	ldmfd   sp!, {r4-r7, pc}

	
*/



	
console:
    stmfd   sp!, {r4, lr}
    ldr     r4, =gpiobase
    ldr     r4, [r4]

loop:
	@@ Read the state of the buttons
	@@ Read GPIO Level Register 0 (GPLEV0)
	ldr 	r3, [r4, #GPLEV0]
    
	mov	    r0, #0      @ will be used to dertermine which switch was set
	mov	    r1, #0		@ will be used to set outputs
	mov	    r2, #0		@ will be used to clear outputs

	tst	    r3, #(1<<17)	    @ check state of pin 17
	moveq   r0, #1

	tst	    r3, #(1<<22)	    @ check state of pin 22
	moveq   r0, #2

	tst	    r3, #(1<<10)	    @ check state of pin 10
	moveq   r0, #3
	
	tst	    r3, #(1<<11)	    @ check state of pin 11
	moveq   r0, #4

    //ldr     r1, =button_set
    //cmp     r0, #0
    //strne   r0, [r1]
return:
    ldmfd   sp!, {r4, pc}

